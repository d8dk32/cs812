
package tc.compiler.tree.visit;

import tc.compiler.Message;
import tc.compiler.Location;
import tc.compiler.tree.*;
import tc.compiler.tree.type.*;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
import tc.compiler.parse.TreeBuilder;
import java.util.ArrayList;

/**
 * Analyze an AST to determine the semantics of the program. Information
 * is left in the AST, and the AST may possibly be changed in order to
 * fully describe the semantics.
 * <p>
 * Using Tree for the type parameter to allow subtrees to be altered
 * by visiting them. The return type is assigned to the fields
 * of a node as the traversal returns back to it.
 * <p>
 * The "visit" method is overloaded for each tree node type.
 */
public final class Analyze extends TreeVisitorBase<Tree>
{

  Scope symbolTable = new Scope(); 
  int whileDepth = 0;
  /** Create an AST semantic analyzer.
   *
   */
  public Analyze()
  {
  }

  /** Called for every node.
   *
   *  @param node node to be visited.
   *  @return value generated by visitor.
   */
  protected Tree visitNode(final Tree node)
  {
    return node.apply(this);
  }

  /** Analyze a binary operator. */
  @Override public Tree visit(final BinaryOperator binaryOperator)
  {
    // recurse to the children
    binaryOperator.setLeft((Expression) visitNode(binaryOperator.getLeft()));
    binaryOperator.setRight((Expression) visitNode(binaryOperator.getRight()));

    Expression left = binaryOperator.getLeft();
    Expression right = binaryOperator.getRight();

     // avoid a cascade of error messages
    if (left.getType().isErrorType() ||
        right.getType().isErrorType())
    {
      // propagate error type up the tree
      binaryOperator.setType(ErrorType.getInstance());

      // do no further analysis
      return binaryOperator;
    }

    // both operands must be integer type
    // and the result type will be integer type

    if (!(left.getType().isIntegerType() &&
        right.getType().isIntegerType()))
    {
      // display error message
      Message.error(binaryOperator.getLoc(), "integer operands expected");

      // set error type in the node
      binaryOperator.setType(ErrorType.getInstance());
    }
    else
    {
      binaryOperator.setType(IntegerType.getInstance());
    }

    return binaryOperator;
  }

  /** Analyze a compilation unit. */
  @Override public Tree visit(final CompilationUnit compilationUnit)
  {
    //check for cyclical inheritiance before analyzing 
    for(ClassDeclaration cd : compilationUnit.getClasses())
    {
      HashMap<String, Boolean> supers = new HashMap<>();
      ClassType classType = ClassType.getInstance(cd.getClassName());
      ClassType nextSuper = classType.getSuperClass();
      boolean cycleFound = false;
      while (nextSuper != null && !cycleFound)
      {
        cycleFound = supers.containsKey(nextSuper.getName());
        supers.put(nextSuper.getName(), true);
        nextSuper = nextSuper.getSuperClass();
      }
      if (cycleFound)
      {
        Message.fatal("Cyclical inheritance detected starting with class " + classType.getName());
      }
    }    

    visitEach(compilationUnit.getClasses());

    //push the main block scope on the scope stack before visiting the main block statements
    symbolTable.pushScope();
    visitEach(compilationUnit.getMainBlock());
    symbolTable.popScope();
    return compilationUnit;
  }

  /** Analyze an integer literal. */
  @Override public Tree visit(final IntegerLiteral integerLiteral)
  {
    long v = 0;
    Type type = IntegerType.getInstance();
    Location loc = integerLiteral.getLoc();

    try
    {
      v = Long.parseLong(integerLiteral.getValue());
    }
    catch(NumberFormatException nfe)
    {
      Message.error(loc, "illegal integer literal");
      type = ErrorType.getInstance();
    }

    // need to worry about -2147483648
    if (v == 2147483648L)
    {
      if (!integerLiteral.isParentUnaryMinus())
      {
        Message.error(loc, "illegal integer literal");
        type = ErrorType.getInstance();
      }
    }
    else if (v > Integer.MAX_VALUE)
    {
      Message.error(loc, "illegal integer literal");
      type = ErrorType.getInstance();
    }

    integerLiteral.setType(type);

    // return the node so that it can be re-assigned by its parent
    return integerLiteral;
  }

  /** Analyze an output statement. */
  @Override public Tree visit(final OutputStatement outputStatement)
  {
    // visit the expression subtree
    outputStatement.setExp((Expression) visitNode(outputStatement.getExp()));

    // avoid cascade of errors
      if (!outputStatement.getExp().getType().isErrorType())
      {
        // check that the expression is int type
        if (!outputStatement.getExp().getType().isIntegerType())
        {
          Message.error(outputStatement.getLoc(), "integer type expected");
        }
      }

    // return the node so that it can be re-assigned by its parent
    return outputStatement;
  }

  /** Analyze a unary operator. */
  @Override public Tree visit(final UnaryOperator unaryOperator)
  {
    // recurse to the child
    unaryOperator.setLeft((Expression) visitNode(unaryOperator.getLeft()));

    Expression left = unaryOperator.getLeft();
    Type leftType = left.getType();

    // avoid a cascade of errors
    if (leftType.isErrorType())
    {
      unaryOperator.setType(leftType);
      return unaryOperator;
    }

    // subtree should be integer type
    // result will be integer type

    if (!(leftType.isIntegerType()))
    {
      Message.error(unaryOperator.getLoc(), "integer operand expected");
      unaryOperator.setType(ErrorType.getInstance());
    }
    else
    {
      unaryOperator.setType(IntegerType.getInstance());
    }

    return unaryOperator;
  }

  //visit variable node
  @Override public Tree visit(final Identifier identifier) {
    //if the identifier has not been defined, bug out.
    if (symbolTable.getSymbol(identifier.getName()) == null)
    {
      if(symbolTable.peekClassAccess() == null)
      {
        Message.error(identifier.getLoc(), "undefined variable " + identifier.getName());
        identifier.setType(ErrorType.getInstance());
      }
      else
      {
        //check if this is really an implied "this" field access
        ClassType classInScope = symbolTable.peekClassAccess();
        if(classInScope.getFieldIndex(identifier.getName()) == -1)
        {
          Message.error(identifier.getLoc(), "undefined variable " + identifier.getName());
          identifier.setType(ErrorType.getInstance());
        }
        //the field exists on the class, so it's actually a field access on an ImpliedThis
        //wrap the identifier in a field access on an implied-this and return the field access
        Message.log("implied this field access found: " + identifier.getName());
        FieldAccess thisAccess = new FieldAccess(identifier.getLoc(), 
                                                 new ImpliedThis(identifier.getLoc(), classInScope),
                                                 identifier);
        thisAccess.setType(classInScope.fieldToType(identifier.getName()));
        if(identifier.isLeftSide())
          { thisAccess.setLeftSide(true); }
        
        return thisAccess;

      }
    }
    else{
      Type type = symbolTable.getSymbol(identifier.getName()).getType();
      identifier.setType(type);
    }
    return identifier;
  }

  //visit declaration statement node
  @Override public Tree visit(final DeclarationStatement declStatement) {

    //visit its child nodes
    for(int x = 0; x < declStatement.getDeclarations().size(); x++)
    {
      Identifier i = declStatement.getDeclarations().get(x);
      Integer depth = declStatement.getDimensionList().get(x);
      //put variable in symbol table
      Type varType = null;
      if (declStatement.getType() == "int")
      {
        if(depth > 0)
        {
          varType = new ArrayType("int", depth);
        }
        else
        {
          varType = IntegerType.getInstance();
        }
      }
      else
      {
        //must be some kind of class type
        if(depth > 0)
        {
          varType = new ArrayType(declStatement.getType(), depth);
        }
        else
        {
          varType = ClassType.getInstance(declStatement.getType());
        }
      }
      if (symbolTable.getSymbol(i.getName()) == null)
      {
        symbolTable.putSymbol(i.getName(), 
              new TypeDepthPair(varType, depth)); 
      }
      else
      {
          Message.error(declStatement.getLoc(), "Duplicate declaration of main block variable " + i.getName());
      }

      visitNode(i);
      
    }

    return declStatement;
  }

  //visit assignment node
  @Override public Tree visit(final Assignment assignment) {
    Type lhsType = ErrorType.getInstance();
    //visit its child nodes
    if(assignment.getIdentifier() instanceof Identifier)
    { 
      Message.log("Assign to id " +  assignment.getLineNumber());
      Tree t = visitNode((Identifier) assignment.getIdentifier()); 
      if(t instanceof FieldAccess)
      {
        Message.log("Actually a field access " +  assignment.getLineNumber());
        FieldAccess theFa = (FieldAccess) t;
        lhsType = theFa.getType();
        LeftSide theLs = (LeftSide) theFa;
        assignment.setIdentifier(theLs);
      }
      else if (t instanceof Identifier)
      {
        lhsType = ((Identifier) assignment.getIdentifier()).getType(); 
      }
    }
    else if (assignment.getIdentifier() instanceof ArrayAccess)
    { 
      visitNode((ArrayAccess) assignment.getIdentifier()); 
      lhsType = ((ArrayAccess) assignment.getIdentifier()).getType(); 
    }
    else if (assignment.getIdentifier() instanceof FieldAccess)
    { 
      visitNode((FieldAccess) assignment.getIdentifier()); 
      lhsType = ((FieldAccess) assignment.getIdentifier()).getType(); 
    }
    
    visitNode(assignment.getExpression());    
    Type exprType = assignment.getExpression().getType();
    
    if(exprType.isClassType() && lhsType.isClassType())
    {
      ClassType exprCt = (ClassType) exprType;
      ClassType lhsCt = (ClassType) lhsType;
      if(lhsCt != exprCt)
      {
        if(exprCt.isSubclassOf(lhsCt))
        {
          //insert widening cast
          Cast cast = new Cast(assignment.getLoc(), 
                              new Identifier(assignment.getLoc(), lhsCt.getName()), 
                              assignment.getExpression()
                              );
          cast.setConversionType(Cast.ConversionType.WIDENING);
          cast.setType(lhsCt);
          assignment.setExpression(cast);
          Message.log("Implicit widening cast: " + exprCt.getName() + " to " + lhsCt.getName());
        }
        else
          Message.error(assignment.getLoc(), "Implicit narrowing cast not allowed");
      }
    }

    return assignment;
  }

  /*visit if/else node
  */
  @Override public Tree visit(final IfElseStatement ifElse) {

    visitNode(ifElse.getCondition());
    if(ifElse.getCondition().getType() != IntegerType.getInstance())
    {
      Message.error(ifElse.getLoc(), "IF condition must be of Integer type");
    }
    
    visitNode(ifElse.getThen());
    visitNode(ifElse.getElse());
    
    return null;
  }

  /*visit while node
  */
  @Override public Tree visit(final WhileStatement whileStatement) {

    visitNode(whileStatement.getCondition());
    if(whileStatement.getCondition().getType() != IntegerType.getInstance())
    {
      Message.error(whileStatement.getLoc(), "WHILE condition must be of Integer type");
    }
    whileDepth ++;
    visitNode(whileStatement.getStatement());
    whileDepth --;
    
    return null;
  }

  /** Visit a break statement node*/
  @Override public Tree visit(final BreakStatement br)
  {
    if(whileDepth <= 0)
    {
      Message.error(br.getLoc(), "Break must be enclosed in a While statement");
    }
    return null;
  }

  /** Visit a continue statement node*/
  @Override public Tree visit(final ContinueStatement c)
  {
    if(whileDepth <= 0)
    {
      Message.error(c.getLoc(), "Continue must be enclosed in a While statement");
    }
    return null;
  }

  /** Visit an ArrayCreationExpression node */
  @Override public Tree visit(final ArrayCreationExpression ace)
  {
    visitNode(ace.getDimExpr());
    if (!ace.getDimExpr().getType().isIntegerType())
    {
      Message.error(ace.getLoc(), "integer expression expected for array length");
    }
    return ace;
  }

  /** visit an ArrayAccess node */
  @Override public Tree visit(final ArrayAccess aa)
  {
    Expression theArray = aa.getTheArray();
    visitNode(theArray);
    Type arrayComponentType = ErrorType.getInstance();
    int line = aa.getLoc().getLine();
    if(theArray instanceof Identifier)
    {
      TypeDepthPair idTDP = symbolTable.getSymbol(((Identifier) theArray).getName());
      aa.setBaseType((ArrayType) idTDP.getType());
      aa.setLayer(idTDP.getDepth());
      if(idTDP.getDepth() < 1)
      { 
        Message.error(aa.getLoc(), "Variable not defined as an array"); 
      }
      else if (idTDP.getType().isArrayType())
      {
        if( ((ArrayType) idTDP.getType()).getComponentType().equals("int"))
        {
          arrayComponentType = IntegerType.getInstance();
        }
        else
        {
          arrayComponentType = ClassType.getInstance(((ArrayType) idTDP.getType()).getComponentType());
        }
      }
      
    }
    else 
    {
      //if it's not an identifier of some kind, it's another arrayAccess
      //just match the type, the inner array access is floating the type
      //up to the out ones
      arrayComponentType = theArray.getType();
      aa.setBaseType( ((ArrayAccess) theArray).getBaseType());
      aa.setLayer( ((ArrayAccess) theArray).getLayer() - 1 );
    }
    aa.setType(arrayComponentType);
    Message.log("aa.type: " + aa.getType().encode() + ", " + line);
    Message.log("theArray.type: " + theArray.getType().encode() + ", " + line);
    visitNode(aa.getDimExpr());
    if(!aa.getDimExpr().getType().isIntegerType())
    {
      Message.error(aa.getLoc(), "Array index must be of integer type");
    }

    return aa;
  }

  /** visit a Cast node */  
  @Override public Tree visit(final Cast c)
  {
    Expression toBeCast = c.getToBeCastExpression();
    visitNode(toBeCast);
    if (c.getPresetType() != null)
    {
      if(!toBeCast.getType().isArrayType())
      {
        Message.error(c.getLoc(), "Incompatible cast types");
        c.setConversionType(Cast.ConversionType.INVALID);
      } else if (!c.getPresetType().compareArrayTypes((ArrayType) toBeCast.getType()))
      {
        Message.error(c.getLoc(), "Incompatible cast types");
        c.setConversionType(Cast.ConversionType.INVALID);
      }
      c.setType(c.getPresetType());
      c.setConversionType(Cast.ConversionType.IDENTITY);
    }
    else if (c.getParenExpression() != null)
    {
      //it should be an identifier in the parens. if it's not I think there's a problem
      
      String typeName = null;
      if(c.getParenExpression() instanceof Identifier) //if there is an identifier in the parens
      {
        //use the identifier string as the type to cast to
        typeName = ((Identifier) c.getParenExpression()).getName();
      }
      else
      { //if it's not an Identifier in the parens
        //just bail out cause something is wrong
        c.setConversionType(Cast.ConversionType.INVALID);
        c.setType(ErrorType.getInstance());
        Message.error(c.getLoc(), "Incompatible cast types");
        return c;
      }

      //if "int" is in the parens, the only legaltype to cast from is int
      if(typeName == "int")
      {
        if(toBeCast.getType() == IntegerType.getInstance())
        {
          c.setConversionType(Cast.ConversionType.IDENTITY);
          c.setType(IntegerType.getInstance());
          return c;
        }
        else
        {
          //cant cast to int from anything but int (except null?)
          c.setConversionType(Cast.ConversionType.INVALID);
          c.setType(ErrorType.getInstance());
          Message.error(c.getLoc(), "Incompatible cast types");
          return c;
        }
      }

      //if there is a class name in parens
      if(typeName != null 
        && ClassType.getInstance(typeName).wasDeclared() 
        && toBeCast.getType() instanceof ClassType)
      { 
        //check for identity conversion
        if(toBeCast.getType() == ClassType.getInstance(typeName))
        {
          c.setConversionType(Cast.ConversionType.IDENTITY);
          c.setType(ClassType.getInstance(typeName));
        }
        else
        { //determine if it's a widening, narrowing or invalid (neither type is a subtype of the other)
          ClassType toClass = ClassType.getInstance(typeName);
          ClassType fromClass = (ClassType) toBeCast.getType();
          c.setType(toClass);
          if(fromClass.isSubclassOf(toClass))
          {
            c.setConversionType(Cast.ConversionType.WIDENING);
          }
          else if (toClass.isSubclassOf(fromClass))
          {
            c.setConversionType(Cast.ConversionType.NARROWING);
          }
          else
          {
            c.setConversionType(Cast.ConversionType.INVALID);
            Message.error(c.getLoc(), "Incompatible cast types");
          }
        }
      }
      else
      {   //something is wrong so error out
          c.setConversionType(Cast.ConversionType.INVALID);
          c.setType(ErrorType.getInstance());
          Message.error(c.getLoc(), "Attempting to cast to undeclared class type.");
          return c;
      }
    }
    Message.log("Conversion type: " + c.getConversionType());
    return c; 
  }

  /** vuisit a fieldaccess node */
  @Override public Tree visit(final FieldAccess fa)
  {
    //first jjust handle array length
    visitNode(fa.getObj());
    if(fa.getObj().getType().isArrayType()) 
    {
      //don't actually visit the length identifier because it won't have been defined, but that's ok
      if(fa.getField().getName().equals("length"))
      {
        fa.setType(IntegerType.getInstance());
      }
      else
      {
        Message.error(fa.getLoc(), "Field not valid for array types");
        fa.setType(ErrorType.getInstance());
      }
    }
    else if (fa.getObj().getType().isClassType())
    {
      ClassType ct = (ClassType) fa.getObj().getType();
      String fieldName = fa.getField().getName();
      if(!ct.wasDeclared() || ct.getFieldIndex(fieldName) == -1)
      {
        Message.error(fa.getLoc(), "Invalid field access");
        fa.setType(ErrorType.getInstance());
      }
      else
      {
        //set the FieldAccess node's type to the type of the field it is accessing
        String fieldType = ct.getFieldType(fieldName);
        int fieldDepth = ct.getFieldDepth(fieldName);
        if (fieldDepth > 0)
          fa.setType(new ArrayType(fieldType, fieldDepth));
        else if (fieldType.equals("int"))
          fa.setType(IntegerType.getInstance());
        else
          fa.setType(ClassType.getInstance(fieldType));
      }
    }
    else
    {
      Message.error(fa.getLoc(), "Field Access not supported for this type");
      fa.setType(ErrorType.getInstance());
    }
    return fa;
  }

  @Override public Tree visit(final ClassDeclaration cd)
  {
    symbolTable.pushScope();
    ClassType cdType = ClassType.getInstance(cd.getClassName());
    symbolTable.pushClassAccess(cdType);
    //visit each ClassBodyDeclaratuion. If it's a Field, add it to this thing's ClassType's list of fields
    //remember to start from the end of the list so that you add the base type's fields before the supertype's

    // for each field declaration
    for(FieldDeclaration fd : cdType.getFieldDecls(true))
    {
      visitNode(fd); //visit the field declaration node
      List<Identifier> fdIds = fd.getDeclarations();
      List<Integer> fdDims = fd.getDimensionList();
      for(int j = 0; j < fdIds.size(); j++) //then for each variable declared on this declaration node
      {
        //add it to the list of Name/type/Depth tuples maintained by the ClassType
        NameTypeDepth ntd = new NameTypeDepth(fdIds.get(j).getName(), fd.getType(), fdDims.get(j));
        cdType.addToFields(ntd);
      }
    }

    //for each method declaration
    for(MethodDeclaration md : cdType.getMethodDecls(true))
    {
      Method newMeth = md.getMethod();
      newMeth.setContainingClass(md.getEnclosingClass());
      md.setMethod(newMeth);
      cdType.addToMethods(newMeth);
    }
    visitEach(cdType.getMethodDecls(true)); //visit the method decls only after they've been "recognized" by the enclosing class

    //for each constructor declaration (cosntructors can't be inherited so we don't want the supers)
    for(ConstructorDeclaration cdecl : cdType.getConstructorDecls(false))
    {
      cdType.addToConstructors(cdecl); 
    }
    visitEach(cdType.getConstructorDecls(false)); //visit the constructor decls only after they've been "recognized" by the enclosing class

    symbolTable.popScope();
    symbolTable.popClassAccess();
    return cd;
  }

  @Override public Tree visit(final FieldDeclaration fd)
  {
    // I don't think I need to do much here actually 
    // all the heavy lifting is being done by the class declaration node above it
    // the related DeclarationStatement (main variable decl) is adding things
    // to the symbol table, nad since these Identifiers won't be in the symbol
    // table I don't think we even need to visit those nodes
    // just make sure if it's a field of class type that the class has been declared

    if(fd.getType() != "int" && !ClassType.getInstance(fd.getType()).wasDeclared())
    {
      Message.error(fd.getLoc(), "Undeclared class type " + fd.getType());
    }

    return fd;
  }

  @Override public Tree visit(final MethodDeclaration md)
  {
    symbolTable.pushScope();
    //not entirely sure what needs to happen here. I guess make sure the return type and param types are all valid,
    //and then visit the body node
    if(md.getType() != "int" && !ClassType.getInstance(md.getType()).wasDeclared())
    {
      Message.error(md.getLoc(), "Undeclared class type " + md.getType());
    }

    for(NameTypeDepth ntd : md.getParams())
    {
      if(ntd.getType() != "int" && !ClassType.getInstance(ntd.getType()).wasDeclared())
      {
        Message.error(md.getLoc(), "Undeclared class type " + ntd.getType());
      }    
    }
    symbolTable.putAllSymbols(md.getParams());
    visitNode(md.getBody());
    symbolTable.popScope();
    return md;
  }

  @Override public Tree visit(final ClassInstanceCreationExpression cice)
  {    
    //set type of CICExpression
    ClassType ct = ClassType.getInstance(cice.getClassName());
    if(!ct.wasDeclared())
    {
      Message.error(cice.getLoc(), "Undeclared class type " + cice.getClassName());
      cice.setType(ErrorType.getInstance());
    }
    else{
      cice.setType(ct);
    }
    
    //TODO
    //handle constructor args at some point
    //find matching constructor declaration
    ClassType classInScope = ct;
    List<ConstructorDeclaration> cdList = classInScope.getConstructors();
    List<Expression> argList = cice.getArgs();
    visitEach(argList); //visit each param expression
    ArrayList<ConstructorDeclaration> potentialMatches = new ArrayList<>(); //will contain a pared down list of constructors with the right number and types of params
    ArrayList<ConstructorDeclaration> matches = new ArrayList<>(); //will containa further pared down list of most specific methods. hopefully just 1
    ArrayList<Type> argTypes = new ArrayList<>();
    for(Expression e : argList)
    {
      argTypes.add(e.getType()); //get all the arg types
    }

    for(ConstructorDeclaration cd : cdList)
    {
      //filter list down to only ones with the right number and type of params
      if(cd.getParams().size() == argList.size() && Cast.isMethodInvocationConversionPermitted(NameTypeDepth.toTypes(cd.getParams()), argTypes))
      {
        potentialMatches.add(cd);
      }
    }

    for(ConstructorDeclaration cd : potentialMatches)
    {
      boolean isSpecificMatch = true; //assume it is a "most specific" match until proven otherwise
      for(ConstructorDeclaration other : potentialMatches)
      {
        if( !Cast.isMethodInvocationConversionPermitted( NameTypeDepth.toTypes( other.getParams() ), 
                                                        NameTypeDepth.toTypes( cd.getParams() )
                                                      )
          )
        {
          isSpecificMatch = false;
          break;
        }
      }
      if(isSpecificMatch)
      {
        matches.add(cd);
      }
    }

    //if a match was found
    if(matches.size() > 0)
    {
      //a match was found
      ConstructorDeclaration match = matches.get(0);
      Message.log("Matched Constructor: " + match.getEncodedName());
      cice.setMatch(match);
      //don't forget to actually slip the Casts in as needed for method invocation conversion
      List<Expression> castedArgsList = new ArrayList<>();
      List<Type> matchParamTypes = NameTypeDepth.toTypes(match.getParams());
      for(int i = 0; i < matchParamTypes.size(); i++)
      {
        Type argType = argTypes.get(i);
        Type paramType = matchParamTypes.get(i);
        if(Cast.isMethodInvocationConversionPermitted(paramType, argType) == Cast.ConversionType.WIDENING)
        {
          castedArgsList.add( new Cast(cice.getLoc(), paramType, cice.getArgs().get(i) ) );
        }
        else
        {
          castedArgsList.add(cice.getArgs().get(i));
        }
      }
      cice.setArgs(castedArgsList);
    }

    return cice;
  }

  @Override public Tree visit(final ConstructorDeclaration cd)
  {
    //make sure the param types are all valid,
    //and then visit the body node
    //make sure the constructor matches its enclosing class
    if (cd.getClassType() != symbolTable.peekClassAccess())
    {
      Message.error(cd.getLoc(), "Constructor type " + cd.getClassName() + " doesn't match class " + symbolTable.peekClassAccess());
    }
    symbolTable.pushScope();
    for(NameTypeDepth ntd : cd.getParams())
    {
      if(ntd.getType() != "int" && !ClassType.getInstance(ntd.getType()).wasDeclared())
      {
        Message.error(cd.getLoc(), "Undeclared class type " + ntd.getType());
      }    
    }
    symbolTable.putAllSymbols(cd.getParams());
    visitEach(cd.getBody());
    symbolTable.popScope();
    return cd;
  }

  @Override public Tree visit(final ConstructorInvocation ci)
  {
    //find matching constructor declaration
    ClassType classInScope = symbolTable.peekClassAccess();
    if(ci.isSuper())
    {
      classInScope = classInScope.getSuperClass();
    }
    List<ConstructorDeclaration> cdList = classInScope.getConstructors();
    List<Expression> argList = ci.getArgs();
    visitEach(argList); //visit each param expression
    ArrayList<ConstructorDeclaration> potentialMatches = new ArrayList<>(); //will contain a pared down list of constructors with the right number and types of params
    ArrayList<ConstructorDeclaration> matches = new ArrayList<>(); //will containa further pared down list of most specific methods. hopefully just 1
    ArrayList<Type> argTypes = new ArrayList<>();
    for(Expression e : argList)
    {
      argTypes.add(e.getType()); //get all the arg types
    }

    for(ConstructorDeclaration cd : cdList)
    {
      //filter list down to only ones with the right number and type of params
      if(cd.getParams().size() == argList.size() && Cast.isMethodInvocationConversionPermitted(NameTypeDepth.toTypes(cd.getParams()), argTypes))
      {
        potentialMatches.add(cd);
      }
    }

    for(ConstructorDeclaration cd : potentialMatches)
    {
      boolean isSpecificMatch = true; //assume it is a "most specific" match until proven otherwise
      for(ConstructorDeclaration other : potentialMatches)
      {
        if( !Cast.isMethodInvocationConversionPermitted( NameTypeDepth.toTypes( other.getParams() ), 
                                                        NameTypeDepth.toTypes( cd.getParams() )
                                                      )
          )
        {
          isSpecificMatch = false;
          break;
        }
      }
      if(isSpecificMatch)
      {
        matches.add(cd);
      }
    }

    //if no matches were found or it is ambiguous
    if(matches.size() == 0)
    {
      Message.error(ci.getLoc(), "No suitable constructor definition found ");
      return ci;
    }

    //a match was found
    ConstructorDeclaration match = matches.get(0);
    Message.log("Matched Constructor: " + match.getEncodedName());
    ci.setMatch(match);
    //don't forget to actually slip the Casts in as needed for method invocation conversion
    List<Expression> castedArgsList = new ArrayList<>();
    List<Type> matchParamTypes = NameTypeDepth.toTypes(match.getParams());
    for(int i = 0; i < matchParamTypes.size(); i++)
    {
      Type argType = argTypes.get(i);
      Type paramType = matchParamTypes.get(i);
      if(Cast.isMethodInvocationConversionPermitted(paramType, argType) == Cast.ConversionType.WIDENING)
      {
        castedArgsList.add( new Cast(ci.getLoc(), paramType, ci.getArgs().get(i) ) );
      }
      else
      {
        castedArgsList.add(ci.getArgs().get(i));
      }
    }
    ci.setArgs(castedArgsList);

    return ci;
  }

  @Override public Tree visit(final MethodInvocation mi)
  {
    //determine the class to find the method from
    ClassType classInScope = symbolTable.peekClassAccess();
    if(mi.getPrimary() != null)
    {
      visitNode(mi.getPrimary());
      if(mi.getPrimary().getType() instanceof ClassType)
      {
        classInScope = (ClassType) mi.getPrimary().getType();
      }
    }

    if(classInScope == null)
    {
      Message.error(mi.getLoc(), "Invalid method invocation");
      return mi;
    }

    if(mi.isSuper())
    {
      classInScope = classInScope.getSuperClass();
    }

    Message.log("Class inScope " + classInScope.getName());

    //find the most specific match for the method
    List<Method> mList = classInScope.getMethods();
    List<Expression> argList = mi.getArgs();
    visitEach(argList); //visit each param expression
    ArrayList<Method> potentialMatches = new ArrayList<>(); //will contain a pared down list of constructors with the right number and types of params
    ArrayList<Method> matches = new ArrayList<>(); //will containa further pared down list of most specific methods. hopefully just 1
    ArrayList<Type> argTypes = new ArrayList<>();
    for(Expression e : argList)
    {
      argTypes.add(e.getType()); //get all the arg types
    }

    for(Method m : mList)
    {
      //filter list down to only ones with the right number and type of params
      if(m.getName().equals(mi.getMethodName()) && m.getParams().size() == argList.size() && Cast.isMethodInvocationConversionPermitted(NameTypeDepth.toTypes(m.getParams()), argTypes))
      {
        potentialMatches.add(m);
      }
    }

    for(Method m : potentialMatches)
    {
      Message.log(m.getEncodedName());
      boolean isSpecificMatch = true; //assume it is a "most specific" match until proven otherwise
      for(Method other : potentialMatches)
      {
        if( !Cast.isMethodInvocationConversionPermitted( NameTypeDepth.toTypes( other.getParams() ), 
                                                        NameTypeDepth.toTypes( m.getParams() )
                                                      )
          )
        {
          isSpecificMatch = false;
          break;
        }
      }
      if(isSpecificMatch)
      {
        matches.add(m);
      }
    }

    //if no matches were found or it is ambiguous
    if(matches.size() == 0)
    {
      Message.error(mi.getLoc(), "No suitable method definition found ");
      return mi;
    }

    //a match was found
    Method match = matches.get(matches.size()-1);
    Message.log("Matched method: " + match.getEncodedName());
    mi.setMatch(match);
    //don't forget to actually slip the Casts in as needed for method invocation conversion
    List<Expression> castedArgsList = new ArrayList<>();
    List<Type> matchParamTypes = NameTypeDepth.toTypes(match.getParams());
    for(int i = 0; i < matchParamTypes.size(); i++)
    {
      Type argType = argTypes.get(i);
      Type paramType = matchParamTypes.get(i);
      if(Cast.isMethodInvocationConversionPermitted(paramType, argType) == Cast.ConversionType.WIDENING)
      {
        castedArgsList.add( new Cast(mi.getLoc(), paramType, mi.getArgs().get(i) ) );
      }
      else
      {
        castedArgsList.add(mi.getArgs().get(i));
      }
    }
    mi.setArgs(castedArgsList);

    return mi;

  }
}

