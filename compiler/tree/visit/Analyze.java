
package tc.compiler.tree.visit;

import tc.compiler.Message;
import tc.compiler.Location;
import tc.compiler.tree.*;
import tc.compiler.tree.type.*;
import java.util.HashMap;

/**
 * Analyze an AST to determine the semantics of the program. Information
 * is left in the AST, and the AST may possibly be changed in order to
 * fully describe the semantics.
 * <p>
 * Using Tree for the type parameter to allow subtrees to be altered
 * by visiting them. The return type is assigned to the fields
 * of a node as the traversal returns back to it.
 * <p>
 * The "visit" method is overloaded for each tree node type.
 */
public final class Analyze extends TreeVisitorBase<Tree>
{

  HashMap<String, TypeDepthPair> symbolTable = new HashMap<>(); 
  int whileDepth = 0;
  /** Create an AST semantic analyzer.
   *
   */
  public Analyze()
  {
  }

  /** Called for every node.
   *
   *  @param node node to be visited.
   *  @return value generated by visitor.
   */
  protected Tree visitNode(final Tree node)
  {
    return node.apply(this);
  }

  /** Analyze a binary operator. */
  @Override public Tree visit(final BinaryOperator binaryOperator)
  {
    // recurse to the children
    binaryOperator.setLeft((Expression) visitNode(binaryOperator.getLeft()));
    binaryOperator.setRight((Expression) visitNode(binaryOperator.getRight()));

    Expression left = binaryOperator.getLeft();
    Expression right = binaryOperator.getRight();

     // avoid a cascade of error messages
    if (left.getType().isErrorType() ||
        right.getType().isErrorType())
    {
      // propagate error type up the tree
      binaryOperator.setType(ErrorType.getInstance());

      // do no further analysis
      return binaryOperator;
    }

    // both operands must be integer type
    // and the result type will be integer type

    if (!(left.getType().isIntegerType() &&
        right.getType().isIntegerType()))
    {
      // display error message
      Message.error(binaryOperator.getLoc(), "integer operands expected");

      // set error type in the node
      binaryOperator.setType(ErrorType.getInstance());
    }
    else
    {
      binaryOperator.setType(IntegerType.getInstance());
    }

    return binaryOperator;
  }

  /** Analyze a compilation unit. */
  @Override public Tree visit(final CompilationUnit compilationUnit)
  {
    visitEach(compilationUnit.getClasses());
    visitEach(compilationUnit.getMainBlock());
    return compilationUnit;
  }

  /** Analyze an integer literal. */
  @Override public Tree visit(final IntegerLiteral integerLiteral)
  {
    long v = 0;
    Type type = IntegerType.getInstance();
    Location loc = integerLiteral.getLoc();

    try
    {
      v = Long.parseLong(integerLiteral.getValue());
    }
    catch(NumberFormatException nfe)
    {
      Message.error(loc, "illegal integer literal");
      type = ErrorType.getInstance();
    }

    // need to worry about -2147483648
    if (v == 2147483648L)
    {
      if (!integerLiteral.isParentUnaryMinus())
      {
        Message.error(loc, "illegal integer literal");
        type = ErrorType.getInstance();
      }
    }
    else if (v > Integer.MAX_VALUE)
    {
      Message.error(loc, "illegal integer literal");
      type = ErrorType.getInstance();
    }

    integerLiteral.setType(type);

    // return the node so that it can be re-assigned by its parent
    return integerLiteral;
  }

  /** Analyze an output statement. */
  @Override public Tree visit(final OutputStatement outputStatement)
  {
    // visit the expression subtree
    outputStatement.setExp((Expression) visitNode(outputStatement.getExp()));

    System.err.println(outputStatement.getExp());
    System.err.println(outputStatement.getExp().getType());

    // avoid cascade of errors
    if (!outputStatement.getExp().getType().isErrorType())
    {
      // check that the expression is int type
      if (!outputStatement.getExp().getType().isIntegerType())
      {
        Message.error(outputStatement.getLoc(), "integer type expected");
      }
    }

    // return the node so that it can be re-assigned by its parent
    return outputStatement;
  }

  /** Analyze a unary operator. */
  @Override public Tree visit(final UnaryOperator unaryOperator)
  {
    // recurse to the child
    unaryOperator.setLeft((Expression) visitNode(unaryOperator.getLeft()));

    Expression left = unaryOperator.getLeft();
    Type leftType = left.getType();

    // avoid a cascade of errors
    if (leftType.isErrorType())
    {
      unaryOperator.setType(leftType);
      return unaryOperator;
    }

    // subtree should be integer type
    // result will be integer type

    if (!(leftType.isIntegerType()))
    {
      Message.error(unaryOperator.getLoc(), "integer operand expected");
      unaryOperator.setType(ErrorType.getInstance());
    }
    else
    {
      unaryOperator.setType(IntegerType.getInstance());
    }

    return unaryOperator;
  }

  //visit variable node
  @Override public Tree visit(final Identifier identifier) {
    Type type = symbolTable.get(identifier.getName()).getType();
    identifier.setType(type);
    return identifier;
  }

  //visit declaration statement node
  @Override public Tree visit(final DeclarationStatement declStatement) {

    //visit its child nodes
    for(int x = 0; x < declStatement.getDeclarations().size(); x++)
    {
      Identifier i = declStatement.getDeclarations().get(x);
      //put variable in symbol table
      symbolTable.put(i.getName(), 
            new TypeDepthPair(declStatement.getType(), declStatement.getDimensionList().get(x))); 
      Identifier nId = (Identifier) visitNode(i);
    }

    return declStatement;
  }

  //visit assignment node
  @Override public Tree visit(final Assignment assignment) {

    //visit its child nodes
    assignment.setIdentifier((LeftSide) visitNode((Expression) assignment.getIdentifier()));
    assignment.setExpression((Expression) visitNode(assignment.getExpression()));    
  

    return assignment;
  }

  /*visit if/else node
  */
  @Override public Tree visit(final IfElseStatement ifElse) {

    visitNode(ifElse.getCondition());
    if(ifElse.getCondition().getType() != IntegerType.getInstance())
    {
      Message.error(ifElse.getLoc(), "IF condition must be of Integer type");
    }
    
    visitNode(ifElse.getThen());
    visitNode(ifElse.getElse());
    
    return null;
  }

  /*visit while node
  */
  @Override public Tree visit(final WhileStatement whileStatement) {

    visitNode(whileStatement.getCondition());
    if(whileStatement.getCondition().getType() != IntegerType.getInstance())
    {
      Message.error(whileStatement.getLoc(), "WHILE condition must be of Integer type");
    }
    whileDepth ++;
    visitNode(whileStatement.getStatement());
    whileDepth --;
    
    return null;
  }

  /** Visit a break statement node*/
  @Override public Tree visit(final BreakStatement br)
  {
    if(whileDepth <= 0)
    {
      Message.error(br.getLoc(), "Break must be enclosed in a While statement");
    }
    return null;
  }

  /** Visit a continue statement node*/
  @Override public Tree visit(final ContinueStatement c)
  {
    if(whileDepth <= 0)
    {
      Message.error(c.getLoc(), "Continue must be enclosed in a While statement");
    }
    return null;
  }

  /** Visit an ArrayCreationExpression node */
  @Override public Tree visit(final ArrayCreationExpression ace)
  {
    visitNode(ace.getDimExpr());
    if (!ace.getDimExpr().getType().isIntegerType())
    {
      Message.error(ace.getLoc(), "integer expression expected for array length");
    }
    return ace;
  }

}

