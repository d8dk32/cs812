
package tc.compiler.tree;

import tc.compiler.Location;
import tc.compiler.tree.type.Type;
import tc.compiler.tree.visit.TreeVisitor;
import tc.compiler.tree.type.*;
import tc.compiler.tree.Expression;

/**
 * Superclass for all AST expression nodes.
 *
 */
public class ArrayCreationExpression extends Expression
{
  // all expressions have a type
  private Type type;
  private Expression dimExpr; //the expression inside the first dimension
  private Integer numDims; //the number of dimensions total.

  /** Construct an array creation expression node. 
   *
   *  @param loc source code location of the node.
   *  @param t the type of the array getting created
   *  @param dimExpr the expression inside the first dimension
   *  @param numDims the number of dimensions on the array being craeted
   */
  public ArrayCreationExpression(final Location loc, Type t, Expression dimExpr, Integer numDims)
  {
    super(loc);
    this.type = t;
    this.dimExpr = dimExpr;
    this.numDims = numDims;
  }

  /** Set the type.
   *
   *  @param type the type to put into the expression node.
   */
  public void setType(Type type)
  {
    this.type = type;
  }

  /** Get the type of the expression node.
   *
   *  @return the type of the expression node.
   */
  public Type getType()
  {
    return this.type;
  }

  /** Get the dimension expression.
   *
   *  @return the expression inside the first dimension.
   */
  public Expression getDimExpr()
  {
    return this.dimExpr;
  }

  /** Get the number of dimensions in this array
   *
   *  @return the number of dimensions
   */
  public Integer getNumDims()
  {
    return this.numDims;
  }

   /** Apply a visitor to the node.
    *
    *  @param visitor the visitor to apply.
    *
    *  @return the value generated by the visitor.
    */
    @Override public <T> T apply(TreeVisitor<T> visitor)
    {
        return visitor.visit(this);
    }

}

