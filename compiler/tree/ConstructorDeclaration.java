
package tc.compiler.tree;

import tc.compiler.Location;
import tc.compiler.tree.visit.TreeVisitor;
import tc.compiler.tree.type.*;
import tc.compiler.tree.Block;
import java.util.List;
import java.util.ArrayList;

/**
 * Superclass for all AST statement nodes.
 *
 */
public class ConstructorDeclaration extends ClassBodyDeclaration
{

  private String className;
  private List<NameTypeDepth> params;
  private List<Statement> body;
  
  public ConstructorDeclaration(final Location loc, String className, List<NameTypeDepth> params, List<Statement> body)
  {
    super(loc);
    this.className = className;
    this.params = params;
    this.body = body;
  }

  /** get, as a string, the class type to be constructed
 * @return string representing the type
  */
  public String getClassName() 
  {
      return this.className;
  }

  public ClassType getClassType()
  {
    return ClassType.getInstance(this.className);
  }

  /** gets list of params
  * @return List
    */
  public List<NameTypeDepth> getParams() 
  {
      return this.params;
  }

  public List<Statement> getBody()
  {
    return this.body;
  }

  public String toString()
  {
    String retval = getClassName() + "( ";
    for(NameTypeDepth ntd : this.params)
    {
      retval += ntd.toString() + ", ";
    }
    retval += ")";
    return retval;
  }

  public String getEncodedName()
  {
    String encName = "@";
    encName += this.className + "$";
    encName += "constructor$";
    for(NameTypeDepth ntd : this.params)
    {
      encName += ntd.getType();
      if(ntd.getDepth() > 0)
        encName += "arr";
      encName += "$";
    }
    return encName;
  }

  /** Apply a visitor to the node.
  *
  *  @param visitor the visitor to apply.
  *
  *  @return the value generated by the visitor.
  */
  @Override public <T> T apply(TreeVisitor<T> visitor)
  {
      return visitor.visit(this);
  }
}

