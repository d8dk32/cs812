package tc.compiler.tree;

import tc.compiler.Location;
import tc.compiler.tree.visit.TreeVisitor;
import tc.compiler.tree.type.*;
import tc.compiler.tree.LeftSide;

/**
 * AST variable node.
 *
 */
public final class Identifier extends Expression implements LeftSide
{
    // the variable name
    private String name;

    private boolean isLeftSide;

    // may be set to true in TreeBuilder
    // used to detect that -2147483648 is not an error
    private boolean parentIsUnaryMinus = false;
    

     /**
     * Create variable node
     *
     * @param loc source code lcoation
     * @param id identifier name
     */

     public Identifier(final Location loc, final String id) {
         super(loc);
         this.name = id;
         this.isLeftSide = false;
     }

    /** Is the parent a unary minus?
    *
    *  @return true if so, and false otherwise
    */
    public boolean isParentUnaryMinus()
    {
        return parentIsUnaryMinus;
    }

    /** Remember that the parent is a unary minus.
    */
    public void setParentIsUnaryMinus()
    {
        this.parentIsUnaryMinus = true;
    }

    /** get name
     * @return variable name
     */
    public String getName()
    {
        return this.name;
    }

    /** set identifier
     * @param id variable name
     */
    public void setName(String id)
    {
        this.name = id;
    }

    /** Apply a visitor to the node.
    *
    *  @param visitor the visitor to apply.
    *
    *  @return the value generated by the visitor.
    */
    @Override public <T> T apply(TreeVisitor<T> visitor)
    {
        return visitor.visit(this);
    }

    /** isLeftSide
     *  @return true if this expression is the left side of an assignment
     */
     public boolean isLeftSide() 
     {
         return this.isLeftSide;
     }

    /** set Left-sided-ness
     *  @param isLs true if this is the left side of an assignment
     */
     public void setLeftSide(boolean isLs)
     {
         this.isLeftSide = isLs;
     }

}