package tc.compiler.tree;

import tc.compiler.Location;
import tc.compiler.tree.visit.TreeVisitor;
import tc.compiler.tree.type.*;
import tc.compiler.tree.LeftSide;
import tc.compiler.tree.Expression;

/** Tree Node for assignment expressions
 */
public final class Assignment extends Expression
{
    private LeftSide identifier;
    private Expression expr;

    /** Create a node for the assignment expression
     * @param loc source code location of the node
     * @param identifier the variable name being assigned to
     * @param expr the expression to be stored
     */

     public Assignment(final Location loc, final LeftSide identifier, final Expression expr)
     {
         super(loc);
         this.identifier = identifier;
         this.expr = expr;
         setType(expr.getType());
     }

    /** get the identifier being assigned to
     * @return the identifier
     */
    public LeftSide getIdentifier()
    {
        return identifier;
    }

    /** set the identifier for this assignment expression
     * @param ls the left side of this assgn expr
    */
    public void setIdentifier (LeftSide ls)
    {
        this.identifier = ls;
    }

    /** get the expression being stored
     * @return the expression being stored
     */
    public Expression getExpression()
    {
        return expr;
    }

    /** set the expression being stored
     * @param exp the expression 
     */
    public void setExpression(Expression exp)
    {
        this.expr = exp;
    }


     /** Apply a visitor to the node.
    *
    *  @param visitor the visitor to apply.
    *
    *  @return the value generated by the visitor.
    */
    @Override public <T> T apply(TreeVisitor<T> visitor)
    {
        return visitor.visit(this);
    }
}